# 🔍 KV 단일 소스 vs DO 단일 소스 비교

## 옵션 1: DO 단일 소스 (현재 제안)

### 구조
```
KV: 메타데이터만 (roomNumber, title, gameMode, playerCount 등)
DO: players 배열 + 게임 상태
```

### 장점
1. **강력한 일관성 보장**
   - Durable Objects는 **단일 인스턴스 보장** (같은 roomId는 항상 같은 DO 인스턴스)
   - `blockConcurrencyWhile()`로 경쟁 조건 방지
   - 트랜잭션 같은 원자적 연산 가능

2. **게임 상태 관리에 최적화**
   - 턴제 게임 로직 (nextTurn, 탈락 처리 등)에 적합
   - 게임 상태가 복잡할 때 유리

3. **과거에 잘 작동했던 부분 유지**
   - 이미 DO로 게임 상태 관리 중
   - 일관성 문제만 해결하면 됨

### 단점
1. **방 목록 조회 시 DO 조회 필요**
   - 모든 방의 DO를 조회해야 함 (느릴 수 있음)
   - 하지만 캐싱으로 해결 가능

2. **초기화 시간**
   - DO는 처음 생성 시 약간의 초기화 시간 필요
   - 하지만 이미 생성되어 있으면 빠름

## 옵션 2: KV 단일 소스 (질문)

### 구조
```
KV: players 배열 + 메타데이터 + 게임 상태
DO: 제거 또는 게임 로직만 (players 관리 안 함)
```

### 장점
1. **방 목록 조회가 빠름**
   - KV의 `list()`로 모든 방 데이터 한 번에 조회
   - DO 조회 불필요

2. **초기화 시간 없음**
   - KV는 즉시 읽기/쓰기 가능
   - DO 초기화 시간 문제 없음

3. **단순함**
   - 하나의 저장소만 사용
   - 동기화 문제 자체가 없음

### 단점
1. **일관성 보장 약함**
   - KV는 **eventual consistency** (최종 일관성)
   - 같은 키를 동시에 업데이트하면 경쟁 조건 발생 가능
   ```javascript
   // 동시에 두 클라이언트가 players 업데이트
   // KV: A가 읽음 → B가 읽음 → A가 쓰기 → B가 쓰기
   // 결과: A의 변경사항이 손실됨
   ```

2. **원자적 연산 불가**
   - `players.push()` + `scores[playerId] = 0` 같은 복합 연산이 안전하지 않음
   - 읽기 → 수정 → 쓰기 사이에 다른 요청이 끼어들 수 있음

3. **게임 상태 관리 어려움**
   - 턴제 게임 로직 (nextTurn, 탈락 처리)에서 경쟁 조건 발생 가능
   ```javascript
   // 턴 전환 시
   // 클라이언트 A: 현재 턴 플레이어 읽기
   // 클라이언트 B: 현재 턴 플레이어 읽기 (같은 값)
   // 클라이언트 A: 다음 턴으로 변경
   // 클라이언트 B: 다음 턴으로 변경 (같은 값으로 덮어씀)
   // 결과: 턴이 제대로 전환되지 않음
   ```

4. **비활성 플레이어 감지 어려움**
   - `lastSeen` 업데이트도 경쟁 조건 발생 가능
   - 여러 플레이어가 동시에 업데이트하면 일부 손실 가능

## 실제 시나리오 비교

### 시나리오: 플레이어가 동시에 입장

#### DO 단일 소스
```javascript
// join-room 요청
1. DO에서 players 읽기 (원자적)
2. players.push(newPlayer) (blockConcurrencyWhile 안에서)
3. persistState (원자적)
→ 안전함, 일관성 보장
```

#### KV 단일 소스
```javascript
// join-room 요청 (동시에 2명이 입장)
플레이어 A:
1. KV에서 players 읽기: [{id: '1'}]
2. players.push({id: 'A'})
3. KV에 쓰기: [{id: '1'}, {id: 'A'}]

플레이어 B (동시에):
1. KV에서 players 읽기: [{id: '1'}] ← A의 변경사항 못 봄
2. players.push({id: 'B'})
3. KV에 쓰기: [{id: '1'}, {id: 'B'}] ← A의 변경사항 손실!
→ 경쟁 조건 발생, 일관성 깨짐
```

### 시나리오: 턴 전환

#### DO 단일 소스
```javascript
// nextTurn 호출
blockConcurrencyWhile(() => {
  // 현재 턴 플레이어 확인
  // 다음 턴으로 전환
  // 상태 저장
})
→ 원자적 연산, 안전함
```

#### KV 단일 소스
```javascript
// nextTurn 호출 (동시에 여러 요청)
1. KV에서 현재 턴 읽기: 'player1'
2. 다음 턴 계산: 'player2'
3. KV에 쓰기: 'player2'

// 하지만 다른 요청이 동시에 실행되면
// 같은 값('player1')을 읽고 같은 값('player2')을 쓰려고 시도
// 결과: 예상치 못한 동작
→ 경쟁 조건 발생
```

## 결론

### KV 단일 소스는 **게임 로직이 복잡할 때 부적합**

이유:
1. **경쟁 조건 발생**: 동시 업데이트 시 데이터 손실 가능
2. **원자적 연산 불가**: 복합 연산이 안전하지 않음
3. **게임 상태 관리 어려움**: 턴 전환, 탈락 처리 등 복잡한 로직에 부적합

### 하지만 **단순한 경우에는 가능**

예:
- 단순 채팅방 (메시지 추가만)
- 단순 투표 (투표 수만 증가)
- 게임 로직이 없는 방 목록

### 우리 게임의 경우

**DO 단일 소스가 적합**:
- 턴제 게임 로직 (nextTurn, 탈락 처리)
- 동시 업데이트가 빈번함 (단어 제출, 턴 전환)
- 게임 상태가 복잡함 (playerLives, turnCount, eliminatedPlayers 등)

**KV 단일 소스는 부적합**:
- 턴 전환 시 경쟁 조건 발생
- 동시 입장 시 데이터 손실 가능
- 게임 상태 일관성 보장 어려움

## 추천

**DO 단일 소스 유지**:
- 게임 로직 복잡도 고려 시 DO가 필수
- KV는 메타데이터만 (방 목록 조회용)
- 일관성 보장이 게임 품질에 중요

**하지만 KV 사용 최소화**:
- players 배열은 DO만 사용
- KV는 방 목록 메타데이터만
- game-state는 DO만 반환
