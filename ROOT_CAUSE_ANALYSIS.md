# 🔍 근본 원인 분석 및 솔직한 평가

## 현재 문제점

1. **입장이 두세번 시도해야 됨**
   - `join-room` API가 실패하거나 타임아웃
   - DO와 KV 동기화 타이밍 문제

2. **효과음이 10초 이상 뒤에 들림**
   - 비동기 처리 지연
   - 폴링 간격(500ms) × 여러 번 = 누적 지연

3. **슬롯이 유령처럼 나타났다 사라짐**
   - DO와 KV 동기화 불일치
   - `persistState` 완료 전에 다음 요청이 오면 이전 상태 반환

4. **나갔던 유저가 다시 나타남**
   - 제거 로직이 제대로 작동하지 않음
   - DO에서 제거되었지만 KV에 남아있거나 그 반대

## 근본 원인

### 1. 폴링 기반의 한계
- 500ms 폴링은 **실시간이 아님**
- 입장/퇴장이 즉시 반영되지 않음
- 최대 500ms 지연 발생

### 2. DO와 KV 동기화 타이밍 문제
```
클라이언트 A: leave-room 요청
  → DO에서 제거 (persistState 시작)
  → 50ms 지연
  → KV 동기화
  → 클라이언트 B 폴링 (이전 상태 받음)
  → 클라이언트 B 폴링 (최신 상태 받음)
```
**문제**: `persistState`가 완료되기 전에 다음 요청이 오면 이전 상태를 받음

### 3. 경쟁 조건 (Race Condition)
```
클라이언트 A: join-room 요청 (KV에 추가)
클라이언트 B: game-state 폴링 (DO 상태 가져옴, 아직 동기화 안됨)
클라이언트 C: game-state 폴링 (KV 상태 가져옴, 이미 추가됨)
```
**문제**: 여러 요청이 동시에 오면 상태가 꼬임

### 4. 복잡한 상태 관리
- DO: 게임 상태 + players
- KV: 방 목록 + players
- 두 소스에서 players를 관리하면서 일관성 유지가 어려움

## 솔직한 평가

### 현재 방식의 한계
**폴링 + DO + KV 방식으로는 완벽한 실시간 동기화가 어렵습니다.**

이유:
1. 폴링은 본질적으로 지연이 있음
2. DO와 KV 동기화는 비동기라 타이밍 문제 발생
3. 여러 소스에서 상태를 관리하면 일관성 유지가 어려움

### 대안

#### 옵션 1: WebSocket/Server-Sent Events
- **장점**: 진짜 실시간 통신
- **단점**: Cloudflare Workers에서 WebSocket 지원이 제한적

#### 옵션 2: 단순화 (DO만 사용, KV 제거)
- **장점**: 단일 소스로 일관성 보장
- **단점**: 방 목록 조회가 느려질 수 있음

#### 옵션 3: 폴링 간격 단축 + 낙관적 업데이트
- **장점**: 빠른 반응
- **단점**: 서버 부하 증가, 여전히 지연 존재

## 추천 방안

**옵션 2 (단순화)**를 추천합니다:
- DO만 사용하여 players 관리
- KV는 방 목록 메타데이터만 저장
- 단일 소스로 일관성 보장

하지만 이것도 완벽하지 않습니다. 근본적으로는 **WebSocket 같은 실시간 통신**이 필요합니다.
